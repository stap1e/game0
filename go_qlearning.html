<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>五子棋强化学习训练系统 (RL-Gobang)</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #4CAF50;
            --board-bg: #e6b380;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: row;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #game-area {
            flex: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #121212;
            position: relative;
        }

        canvas {
            background-color: var(--board-bg);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            border-radius: 4px;
        }

        #sidebar {
            flex: 1;
            background-color: var(--panel-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-left: 1px solid #444;
            overflow-y: auto;
        }

        h2 { margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 10px; }
        
        .stat-box {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 5px;
        }

        .weights-display {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-family: monospace;
            font-size: 12px;
        }

        .weight-row {
            display: flex;
            justify-content: space-between;
        }

        .bar-container {
            width: 100px;
            height: 10px;
            background: #444;
            margin-left: 10px;
            position: relative;
        }
        .bar-fill {
            height: 100%;
            background: var(--accent-color);
            transition: width 0.2s;
        }

        button {
            padding: 12px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        button:hover { background-color: #45a049; }
        button.stop { background-color: #f44336; }
        button:disabled { background-color: #555; cursor: not-allowed; }

        #log {
            flex: 1;
            background: #000;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
            border: 1px solid #444;
            color: #0f0;
        }

        .toggle-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
    </style>
</head>
<body>

<div id="game-area">
    <canvas id="board" width="600" height="600"></canvas>
</div>

<div id="sidebar">
    <h2>RL 训练控制台</h2>
    
    <div class="stat-box">
        <div>状态: <span id="status-text" style="color: #4CAF50">准备就绪</span></div>
        <div>训练局数: <span id="episode-count">0</span></div>
        <div>当前胜率 (最近50局): <span id="win-rate">0%</span></div>
        <div>Epsilon (探索率): <span id="epsilon-val">0.2</span></div>
    </div>

    <div class="toggle-group">
        <button id="btn-train-start">开始极速训练 (Self-Play)</button>
        <button id="btn-train-stop" class="stop" disabled>停止</button>
    </div>
    <button id="btn-play-ai">人机对战 (测试模型)</button>
    <button id="btn-reset">重置权重</button>

    <h3>特征权重 (Weights)</h3>
    <div id="weights-container" class="weights-display stat-box">
        <!-- 权重将通过 JS 动态生成 -->
    </div>

    <h3>训练日志</h3>
    <div id="log"></div>
</div>

<script>
/**
 * 五子棋强化学习核心逻辑
 * 作者: 资深游戏开发专家
 */

// --- 常量定义 ---
const BOARD_SIZE = 15;
const CELL_SIZE = 40;
const EMPTY = 0;
const BLACK = 1;
const WHITE = 2;

// 特征定义 (基于模式匹配)
const FEATURES = {
    'WIN5': { pattern: '11111', initial: 10000 },
    'LIVE4': { pattern: '011110', initial: 300 },
    'DEAD4': { pattern: '11110', initial: 50 },  // 也包含 01111
    'LIVE3': { pattern: '01110', initial: 50 },
    'DEAD3': { pattern: '11100', initial: 10 },
    'LIVE2': { pattern: '01100', initial: 5 },
    'DEAD2': { pattern: '11000', initial: 1 }
};

// 全局变量
let board = [];
let ctx = document.getElementById('board').getContext('2d');
let isTraining = false;
let trainingInterval = null;
let episodes = 0;
let winHistory = []; // 记录最近胜负 1=BlackWin, 0=WhiteWin
let weights = {};
let epsilon = 0.2; // 探索率
let learningRate = 0.01;
let isHumanPlaying = false;
let humanTurn = false; // 人类执黑

// --- 初始化 ---
function init() {
    initBoard();
    initWeights();
    drawBoard();
    renderWeights();
    log("系统初始化完成。请点击“开始极速训练”来训练AI。");
}

function initBoard() {
    board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
}

function initWeights() {
    for (let key in FEATURES) {
        weights[key] = FEATURES[key].initial;
    }
}

// --- 绘图逻辑 ---
function drawBoard() {
    // 清空
    ctx.fillStyle = '#e6b380';
    ctx.fillRect(0, 0, 600, 600);

    // 网格
    ctx.beginPath();
    ctx.strokeStyle = '#000';
    for (let i = 0; i < BOARD_SIZE; i++) {
        // 横线
        ctx.moveTo(20, 20 + i * CELL_SIZE);
        ctx.lineTo(580, 20 + i * CELL_SIZE);
        // 竖线
        ctx.moveTo(20 + i * CELL_SIZE, 20);
        ctx.lineTo(20 + i * CELL_SIZE, 580);
    }
    ctx.stroke();

    // 棋子
    for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x] !== EMPTY) {
                drawPiece(x, y, board[y][x]);
            }
        }
    }
    
    // 标记最后一步
    if (lastMove) {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(20 + lastMove.x * CELL_SIZE, 20 + lastMove.y * CELL_SIZE, 3, 0, 2 * Math.PI);
        ctx.fill();
    }
}

function drawPiece(x, y, color) {
    ctx.beginPath();
    ctx.arc(20 + x * CELL_SIZE, 20 + y * CELL_SIZE, 18, 0, 2 * Math.PI);
    ctx.fillStyle = color === BLACK ? '#000' : '#fff';
    ctx.fill();
    if (color === WHITE) {
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

// --- 核心 AI 逻辑 (特征提取与评估) ---

// 将棋盘特定方向转换为字符串，用于正则匹配
// player: 当前评估的玩家颜色
function getLineString(x, y, dx, dy, player) {
    let str = "";
    // 向前取4个，向后取4个，组成长度9的探测窗口
    for (let k = -4; k <= 4; k++) {
        let nx = x + k * dx;
        let ny = y + k * dy;
        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
            str += "X"; // 边界
        } else {
            let val = board[ny][nx];
            if (val === EMPTY) str += "0";
            else if (val === player) str += "1";
            else str += "2"; // 敌方
        }
    }
    return str;
}

// 评估某个位置下子后的局面分数
function evaluatePosition(x, y, player) {
    let score = 0;
    
    // 临时下子
    board[y][x] = player;

    // 4个方向: 横、竖、左斜、右斜
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    
    for (let d of directions) {
        let str = getLineString(x, y, d[0], d[1], player);
        
        for (let key in FEATURES) {
            let pattern = FEATURES[key].pattern;
            // 简单的正则匹配包含
            // 注意：这只是近似，不处理重叠情况，为了性能简化
            if (str.includes(pattern)) {
                score += weights[key];
            }
            // 处理反转模式 (如 01111 vs 11110)
            let revPattern = pattern.split('').reverse().join('');
            if (pattern !== revPattern && str.includes(revPattern)) {
                score += weights[key];
            }
        }
    }

    // 还要考虑防守：如果我不下这里，对方下这里得分多少？
    // 这是一个简单的 Minimax 思想的一层深度
    let opponent = player === BLACK ? WHITE : BLACK;
    board[y][x] = opponent; // 假设对方下
    let defenseScore = 0;
    for (let d of directions) {
        let str = getLineString(x, y, d[0], d[1], opponent);
        for (let key in FEATURES) {
            let pattern = FEATURES[key].pattern;
            if (str.includes(pattern)) {
                // 防守权重通常比进攻高一点，或者由 AI 自行学习
                defenseScore += weights[key] * 0.8; 
            }
            let revPattern = pattern.split('').reverse().join('');
            if (pattern !== revPattern && str.includes(revPattern)) {
                defenseScore += weights[key] * 0.8;
            }
        }
    }

    // 恢复
    board[y][x] = EMPTY;

    return score + defenseScore;
}

// AI 决策
function getBestMove(player) {
    // 探索 (Epsilon-Greedy)
    if (isTraining && Math.random() < epsilon) {
        let emptySpots = [];
        for(let y=0; y<BOARD_SIZE; y++) 
            for(let x=0; x<BOARD_SIZE; x++) 
                if(board[y][x] === EMPTY) emptySpots.push({x, y});
        // 优化：只在有棋子的周围探索，提高效率
        if (emptySpots.length > 0) {
             // 简单的启发式随机：随机选一个，但优先选中间
             return emptySpots[Math.floor(Math.random() * emptySpots.length)];
        }
    }

    let bestScore = -Infinity;
    let bestMoves = [];
    
    // 性能优化：只搜索有棋子的邻域
    let candidateMoves = new Set();
    let hasPieces = false;
    for(let y=0; y<BOARD_SIZE; y++) {
        for(let x=0; x<BOARD_SIZE; x++) {
            if (board[y][x] !== EMPTY) {
                hasPieces = true;
                for(let dy=-1; dy<=1; dy++) {
                    for(let dx=-1; dx<=1; dx++) {
                        let nx = x+dx, ny = y+dy;
                        if(nx>=0 && nx<BOARD_SIZE && ny>=0 && ny<BOARD_SIZE && board[ny][nx] === EMPTY) {
                            candidateMoves.add(`${nx},${ny}`);
                        }
                    }
                }
            }
        }
    }

    // 第一步下天元
    if (!hasPieces) return {x: 7, y: 7};

    candidateMoves.forEach(pos => {
        let [nx, ny] = pos.split(',').map(Number);
        let score = evaluatePosition(nx, ny, player);
        if (score > bestScore) {
            bestScore = score;
            bestMoves = [{x: nx, y: ny}];
        } else if (score === bestScore) {
            bestMoves.push({x: nx, y: ny});
        }
    });

    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
}

// --- 游戏流程与训练 ---

let lastMove = null;

function checkWin(x, y, player) {
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    for (let d of directions) {
        let count = 1;
        // 正向
        for (let k=1; k<5; k++) {
            let nx = x + k*d[0], ny = y + k*d[1];
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE||board[ny][nx]!==player) break;
            count++;
        }
        // 反向
        for (let k=1; k<5; k++) {
            let nx = x - k*d[0], ny = y - k*d[1];
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE||board[ny][nx]!==player) break;
            count++;
        }
        if (count >= 5) return true;
    }
    return false;
}

// 训练一局
function playTrainingGame() {
    initBoard();
    let currentPlayer = BLACK;
    let moves = []; // 记录整局步数：{x, y, player, features_found}
    let gameOver = false;
    let winner = 0;

    // 限制步数防止死循环
    let steps = 0;
    while (!gameOver && steps < 225) {
        let move = getBestMove(currentPlayer);
        if (!move) { gameOver = true; break; } // 平局

        board[move.y][move.x] = currentPlayer;
        lastMove = move;

        // 记录这一步触发的特征（简化版，用于反向传播）
        // 实际上应该记录Feature Vector，这里简化处理
        moves.push({player: currentPlayer, ...move});

        if (checkWin(move.x, move.y, currentPlayer)) {
            gameOver = true;
            winner = currentPlayer;
        } else {
            currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
        }
        steps++;
    }

    episodes++;
    updateStats(winner);
    
    // 学习阶段 (Backpropagation of Rewards)
    // 简单的规则：赢家的关键特征权重增加，输家减少
    if (winner !== 0) {
        learnFromGame(moves, winner);
    }
    
    // 每10局绘制一次，避免太闪
    if (episodes % 10 === 0) {
        drawBoard();
        renderWeights();
    }
}

function learnFromGame(moves, winner) {
    // 这是一个非常简化的 Temporal Difference / Monte Carlo 更新
    // 我们倒序查看，越接近胜利的步数，其特征权重调整越大
    let decay = 1.0; 
    for (let i = moves.length - 1; i >= 0; i--) {
        let move = moves[i];
        // 如果这步棋是赢家下的
        let isWinnerMove = (move.player === winner);
        let rewardSignal = isWinnerMove ? 1 : -1;

        // 重新分析这一步棋当时的特征
        // 注意：为了简化，我们这里假设当前 board 状态近似于当时
        // (严格来说应该回滚 board，但那太慢了。我们只取最后的关键几步特征)
        if (i > moves.length - 10) { // 只关注最后几步
            adjustWeights(move.x, move.y, move.player, rewardSignal * decay);
        }
        decay *= 0.9; // 衰减
    }
}

function adjustWeights(x, y, player, signal) {
    // 检测这一步形成了什么特征，调整该特征权重
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    let adjustedKeys = new Set();

    for (let d of directions) {
        let str = getLineString(x, y, d[0], d[1], player);
        for (let key in FEATURES) {
            if (str.includes(FEATURES[key].pattern) && !adjustedKeys.has(key)) {
                // 更新公式: W = W + lr * signal
                // 只有当权重不太离谱时才更新，防止溢出
                weights[key] += learningRate * signal * 10; 
                // 保持权重非负
                if (weights[key] < 0) weights[key] = 0;
                adjustedKeys.add(key);
            }
        }
    }
}

function updateStats(winner) {
    if (winner === BLACK) winHistory.push(1);
    else if (winner === WHITE) winHistory.push(0);
    
    if (winHistory.length > 50) winHistory.shift();
    
    let winCount = winHistory.filter(w => w === 1).length;
    let rate = winHistory.length ? Math.round((winCount / winHistory.length) * 100) : 0;
    
    document.getElementById('episode-count').innerText = episodes;
    document.getElementById('win-rate').innerText = rate + "% (黑棋)";
    
    // 随训练减少 epsilon
    if (episodes % 100 === 0 && epsilon > 0.05) epsilon -= 0.01;
    document.getElementById('epsilon-val').innerText = epsilon.toFixed(2);
}

// --- UI 交互 ---

function renderWeights() {
    let container = document.getElementById('weights-container');
    container.innerHTML = '';
    let maxW = Math.max(...Object.values(weights));
    
    for (let key in weights) {
        let w = weights[key];
        let percent = (w / 15000) * 100; // 归一化显示
        if (percent > 100) percent = 100;
        
        let html = `
            <div class="weight-row">
                <span>${key}</span>
                <span>${Math.round(w)}</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill" style="width: ${percent}%"></div>
            </div>
        `;
        let div = document.createElement('div');
        div.innerHTML = html;
        container.appendChild(div);
    }
}

function log(msg) {
    let logDiv = document.getElementById('log');
    let p = document.createElement('div');
    p.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logDiv.prepend(p);
}

// 按钮事件
document.getElementById('btn-train-start').onclick = () => {
    if (isHumanPlaying) return;
    isTraining = true;
    isHumanPlaying = false;
    document.getElementById('status-text').innerText = "正在训练 (Self-Play)...";
    document.getElementById('status-text').style.color = "#FFC107";
    document.getElementById('btn-train-start').disabled = true;
    document.getElementById('btn-train-stop').disabled = false;
    document.getElementById('btn-play-ai').disabled = true;
    
    log("开始训练...");
    trainingInterval = setInterval(playTrainingGame, 10); // 极速
};

document.getElementById('btn-train-stop').onclick = () => {
    isTraining = false;
    clearInterval(trainingInterval);
    document.getElementById('status-text').innerText = "训练暂停";
    document.getElementById('status-text').style.color = "#eee";
    document.getElementById('btn-train-start').disabled = false;
    document.getElementById('btn-train-stop').disabled = true;
    document.getElementById('btn-play-ai').disabled = false;
    log("训练已停止。");
};

document.getElementById('btn-play-ai').onclick = () => {
    isTraining = false;
    clearInterval(trainingInterval);
    isHumanPlaying = true;
    humanTurn = true; // 人类执黑先行
    initBoard();
    drawBoard();
    lastMove = null;
    
    document.getElementById('status-text').innerText = "人机对战 (你执黑)";
    document.getElementById('status-text').style.color = "#03A9F4";
    document.getElementById('btn-train-start').disabled = true;
    document.getElementById('btn-play-ai').disabled = true;
    document.getElementById('btn-reset').innerText = "退出对战";
    log("人机对战开始。请在棋盘上下子。");
};

document.getElementById('btn-reset').onclick = () => {
    if (isHumanPlaying) {
        isHumanPlaying = false;
        document.getElementById('btn-train-start').disabled = false;
        document.getElementById('btn-play-ai').disabled = false;
        document.getElementById('btn-reset').innerText = "重置权重";
        document.getElementById('status-text').innerText = "准备就绪";
        return;
    }
    initWeights();
    episodes = 0;
    winHistory = [];
    epsilon = 0.2;
    renderWeights();
    updateStats(0);
    log("权重已重置为初始值。");
};

// 鼠标点击下子 (人机对战)
document.getElementById('board').onclick = (e) => {
    if (!isHumanPlaying || !humanTurn) return;
    
    let rect = document.getElementById('board').getBoundingClientRect();
    let x = Math.round((e.clientX - rect.left - 20) / CELL_SIZE);
    let y = Math.round((e.clientY - rect.top - 20) / CELL_SIZE);
    
    if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
    if (board[y][x] !== EMPTY) return;
    
    // 人类下子
    board[y][x] = BLACK;
    lastMove = {x, y};
    drawBoard();
    
    if (checkWin(x, y, BLACK)) {
        log("你赢了！");
        alert("你赢了！");
        isHumanPlaying = false;
        return;
    }
    
    humanTurn = false;
    
    // AI 下子
    setTimeout(() => {
        // AI 使用当前训练好的权重
        let aiMove = getBestMove(WHITE);
        if (!aiMove) { alert("平局"); return; }
        
        board[aiMove.y][aiMove.x] = WHITE;
        lastMove = aiMove;
        drawBoard();
        
        if (checkWin(aiMove.x, aiMove.y, WHITE)) {
            log("AI 赢了！");
            alert("AI 赢了！");
            isHumanPlaying = false;
        } else {
            humanTurn = true;
        }
    }, 100);
};

init();

</script>
</body>
</html>